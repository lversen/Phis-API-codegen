# coding: utf-8

"""
    OpenSilex API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.4.7-rdg
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.csv_cell import CSVCell
from openapi_client.models.csv_datatype_error import CSVDatatypeError
from openapi_client.models.csv_duplicate_uri_error import CSVDuplicateURIError
from openapi_client.models.csv_header import CsvHeader
from openapi_client.models.csvuri_not_found_error import CSVURINotFoundError
from typing import Optional, Set
from typing_extensions import Self

class CSVValidationModel(BaseModel):
    """
    CSVValidationModel
    """ # noqa: E501
    missing_headers: Optional[List[StrictStr]] = Field(default=None, alias="missingHeaders")
    empty_headers: Optional[List[StrictInt]] = Field(default=None, alias="emptyHeaders")
    invalid_header_uris: Optional[Dict[str, StrictStr]] = Field(default=None, alias="invalidHeaderURIs")
    datatype_errors: Optional[Dict[str, List[CSVDatatypeError]]] = Field(default=None, alias="datatypeErrors")
    uri_not_found_errors: Optional[Dict[str, List[CSVURINotFoundError]]] = Field(default=None, alias="uriNotFoundErrors")
    invalid_uri_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidURIErrors")
    missing_required_value_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="missingRequiredValueErrors")
    invalid_value_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidValueErrors")
    already_existing_uri_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="alreadyExistingURIErrors")
    duplicate_uri_errors: Optional[Dict[str, List[CSVDuplicateURIError]]] = Field(default=None, alias="duplicateURIErrors")
    invalid_row_size_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidRowSizeErrors")
    invalid_date_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidDateErrors")
    nb_object_imported: Optional[StrictInt] = Field(default=None, alias="nbObjectImported")
    validation_token: Optional[StrictStr] = Field(default=None, alias="validationToken")
    csv_header: Optional[CsvHeader] = Field(default=None, alias="csvHeader")
    __properties: ClassVar[List[str]] = ["missingHeaders", "emptyHeaders", "invalidHeaderURIs", "datatypeErrors", "uriNotFoundErrors", "invalidURIErrors", "missingRequiredValueErrors", "invalidValueErrors", "alreadyExistingURIErrors", "duplicateURIErrors", "invalidRowSizeErrors", "invalidDateErrors", "nbObjectImported", "validationToken", "csvHeader"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CSVValidationModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in datatype_errors (dict of array)
        _field_dict_of_array = {}
        if self.datatype_errors:
            for _key_datatype_errors in self.datatype_errors:
                if self.datatype_errors[_key_datatype_errors] is not None:
                    _field_dict_of_array[_key_datatype_errors] = [
                        _item.to_dict() for _item in self.datatype_errors[_key_datatype_errors]
                    ]
            _dict['datatypeErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in uri_not_found_errors (dict of array)
        _field_dict_of_array = {}
        if self.uri_not_found_errors:
            for _key_uri_not_found_errors in self.uri_not_found_errors:
                if self.uri_not_found_errors[_key_uri_not_found_errors] is not None:
                    _field_dict_of_array[_key_uri_not_found_errors] = [
                        _item.to_dict() for _item in self.uri_not_found_errors[_key_uri_not_found_errors]
                    ]
            _dict['uriNotFoundErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_uri_errors:
            for _key_invalid_uri_errors in self.invalid_uri_errors:
                if self.invalid_uri_errors[_key_invalid_uri_errors] is not None:
                    _field_dict_of_array[_key_invalid_uri_errors] = [
                        _item.to_dict() for _item in self.invalid_uri_errors[_key_invalid_uri_errors]
                    ]
            _dict['invalidURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in missing_required_value_errors (dict of array)
        _field_dict_of_array = {}
        if self.missing_required_value_errors:
            for _key_missing_required_value_errors in self.missing_required_value_errors:
                if self.missing_required_value_errors[_key_missing_required_value_errors] is not None:
                    _field_dict_of_array[_key_missing_required_value_errors] = [
                        _item.to_dict() for _item in self.missing_required_value_errors[_key_missing_required_value_errors]
                    ]
            _dict['missingRequiredValueErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_value_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_value_errors:
            for _key_invalid_value_errors in self.invalid_value_errors:
                if self.invalid_value_errors[_key_invalid_value_errors] is not None:
                    _field_dict_of_array[_key_invalid_value_errors] = [
                        _item.to_dict() for _item in self.invalid_value_errors[_key_invalid_value_errors]
                    ]
            _dict['invalidValueErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in already_existing_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.already_existing_uri_errors:
            for _key_already_existing_uri_errors in self.already_existing_uri_errors:
                if self.already_existing_uri_errors[_key_already_existing_uri_errors] is not None:
                    _field_dict_of_array[_key_already_existing_uri_errors] = [
                        _item.to_dict() for _item in self.already_existing_uri_errors[_key_already_existing_uri_errors]
                    ]
            _dict['alreadyExistingURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicate_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicate_uri_errors:
            for _key_duplicate_uri_errors in self.duplicate_uri_errors:
                if self.duplicate_uri_errors[_key_duplicate_uri_errors] is not None:
                    _field_dict_of_array[_key_duplicate_uri_errors] = [
                        _item.to_dict() for _item in self.duplicate_uri_errors[_key_duplicate_uri_errors]
                    ]
            _dict['duplicateURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_row_size_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_row_size_errors:
            for _key_invalid_row_size_errors in self.invalid_row_size_errors:
                if self.invalid_row_size_errors[_key_invalid_row_size_errors] is not None:
                    _field_dict_of_array[_key_invalid_row_size_errors] = [
                        _item.to_dict() for _item in self.invalid_row_size_errors[_key_invalid_row_size_errors]
                    ]
            _dict['invalidRowSizeErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_date_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_date_errors:
            for _key_invalid_date_errors in self.invalid_date_errors:
                if self.invalid_date_errors[_key_invalid_date_errors] is not None:
                    _field_dict_of_array[_key_invalid_date_errors] = [
                        _item.to_dict() for _item in self.invalid_date_errors[_key_invalid_date_errors]
                    ]
            _dict['invalidDateErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of csv_header
        if self.csv_header:
            _dict['csvHeader'] = self.csv_header.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CSVValidationModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "missingHeaders": obj.get("missingHeaders"),
            "emptyHeaders": obj.get("emptyHeaders"),
            "invalidHeaderURIs": obj.get("invalidHeaderURIs"),
            "datatypeErrors": dict(
                (_k,
                        [CSVDatatypeError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("datatypeErrors", {}).items()
            ),
            "uriNotFoundErrors": dict(
                (_k,
                        [CSVURINotFoundError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("uriNotFoundErrors", {}).items()
            ),
            "invalidURIErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidURIErrors", {}).items()
            ),
            "missingRequiredValueErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("missingRequiredValueErrors", {}).items()
            ),
            "invalidValueErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidValueErrors", {}).items()
            ),
            "alreadyExistingURIErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("alreadyExistingURIErrors", {}).items()
            ),
            "duplicateURIErrors": dict(
                (_k,
                        [CSVDuplicateURIError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicateURIErrors", {}).items()
            ),
            "invalidRowSizeErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidRowSizeErrors", {}).items()
            ),
            "invalidDateErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidDateErrors", {}).items()
            ),
            "nbObjectImported": obj.get("nbObjectImported"),
            "validationToken": obj.get("validationToken"),
            "csvHeader": CsvHeader.from_dict(obj["csvHeader"]) if obj.get("csvHeader") is not None else None
        })
        return _obj


