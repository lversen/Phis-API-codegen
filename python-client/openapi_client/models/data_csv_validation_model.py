# coding: utf-8

"""
    OpenSilex API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.4.7-rdg
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.annotation_model import AnnotationModel
from openapi_client.models.csv_cell import CSVCell
from openapi_client.models.csv_datatype_error import CSVDatatypeError
from openapi_client.models.csv_duplicate_uri_error import CSVDuplicateURIError
from openapi_client.models.csv_header import CsvHeader
from openapi_client.models.csvuri_not_found_error import CSVURINotFoundError
from typing import Optional, Set
from typing_extensions import Self

class DataCSVValidationModel(BaseModel):
    """
    DataCSVValidationModel
    """ # noqa: E501
    missing_headers: Optional[List[StrictStr]] = Field(default=None, alias="missingHeaders")
    empty_headers: Optional[List[StrictInt]] = Field(default=None, alias="emptyHeaders")
    invalid_header_uris: Optional[Dict[str, StrictStr]] = Field(default=None, alias="invalidHeaderURIs")
    datatype_errors: Optional[Dict[str, List[CSVDatatypeError]]] = Field(default=None, alias="datatypeErrors")
    uri_not_found_errors: Optional[Dict[str, List[CSVURINotFoundError]]] = Field(default=None, alias="uriNotFoundErrors")
    invalid_uri_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidURIErrors")
    missing_required_value_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="missingRequiredValueErrors")
    invalid_value_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidValueErrors")
    already_existing_uri_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="alreadyExistingURIErrors")
    duplicate_uri_errors: Optional[Dict[str, List[CSVDuplicateURIError]]] = Field(default=None, alias="duplicateURIErrors")
    invalid_row_size_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidRowSizeErrors")
    invalid_date_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidDateErrors")
    nb_object_imported: Optional[StrictInt] = Field(default=None, alias="nbObjectImported")
    validation_token: Optional[StrictStr] = Field(default=None, alias="validationToken")
    csv_header: Optional[CsvHeader] = Field(default=None, alias="csvHeader")
    invalid_object_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidObjectErrors")
    invalid_annotation_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidAnnotationErrors")
    invalid_target_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidTargetErrors")
    invalid_data_type_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidDataTypeErrors")
    invalid_experiment_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidExperimentErrors")
    invalid_device_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="invalidDeviceErrors")
    device_choice_ambiguity_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="deviceChoiceAmbiguityErrors")
    duplicated_data_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="duplicatedDataErrors")
    duplicated_object_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="duplicatedObjectErrors")
    duplicated_target_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="duplicatedTargetErrors")
    duplicated_experiment_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="duplicatedExperimentErrors")
    duplicated_device_errors: Optional[Dict[str, List[CSVCell]]] = Field(default=None, alias="duplicatedDeviceErrors")
    headers: Optional[List[StrictStr]] = None
    headers_labels: Optional[List[StrictStr]] = Field(default=None, alias="headersLabels")
    annotations_on_objects: Optional[List[AnnotationModel]] = Field(default=None, alias="annotationsOnObjects")
    nb_lines_imported: Optional[StrictInt] = Field(default=None, alias="nbLinesImported")
    nb_lines_to_import: Optional[StrictInt] = Field(default=None, alias="nbLinesToImport")
    validation_step: Optional[StrictBool] = Field(default=None, alias="validationStep")
    insertion_step: Optional[StrictBool] = Field(default=None, alias="insertionStep")
    valid_csv: Optional[StrictBool] = Field(default=None, alias="validCSV")
    too_large_dataset: Optional[StrictBool] = Field(default=None, alias="tooLargeDataset")
    error_message: Optional[StrictStr] = Field(default=None, alias="errorMessage")
    __properties: ClassVar[List[str]] = ["missingHeaders", "emptyHeaders", "invalidHeaderURIs", "datatypeErrors", "uriNotFoundErrors", "invalidURIErrors", "missingRequiredValueErrors", "invalidValueErrors", "alreadyExistingURIErrors", "duplicateURIErrors", "invalidRowSizeErrors", "invalidDateErrors", "nbObjectImported", "validationToken", "csvHeader", "invalidObjectErrors", "invalidAnnotationErrors", "invalidTargetErrors", "invalidDataTypeErrors", "invalidExperimentErrors", "invalidDeviceErrors", "deviceChoiceAmbiguityErrors", "duplicatedDataErrors", "duplicatedObjectErrors", "duplicatedTargetErrors", "duplicatedExperimentErrors", "duplicatedDeviceErrors", "headers", "headersLabels", "annotationsOnObjects", "nbLinesImported", "nbLinesToImport", "validationStep", "insertionStep", "validCSV", "tooLargeDataset", "errorMessage"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DataCSVValidationModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in datatype_errors (dict of array)
        _field_dict_of_array = {}
        if self.datatype_errors:
            for _key_datatype_errors in self.datatype_errors:
                if self.datatype_errors[_key_datatype_errors] is not None:
                    _field_dict_of_array[_key_datatype_errors] = [
                        _item.to_dict() for _item in self.datatype_errors[_key_datatype_errors]
                    ]
            _dict['datatypeErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in uri_not_found_errors (dict of array)
        _field_dict_of_array = {}
        if self.uri_not_found_errors:
            for _key_uri_not_found_errors in self.uri_not_found_errors:
                if self.uri_not_found_errors[_key_uri_not_found_errors] is not None:
                    _field_dict_of_array[_key_uri_not_found_errors] = [
                        _item.to_dict() for _item in self.uri_not_found_errors[_key_uri_not_found_errors]
                    ]
            _dict['uriNotFoundErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_uri_errors:
            for _key_invalid_uri_errors in self.invalid_uri_errors:
                if self.invalid_uri_errors[_key_invalid_uri_errors] is not None:
                    _field_dict_of_array[_key_invalid_uri_errors] = [
                        _item.to_dict() for _item in self.invalid_uri_errors[_key_invalid_uri_errors]
                    ]
            _dict['invalidURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in missing_required_value_errors (dict of array)
        _field_dict_of_array = {}
        if self.missing_required_value_errors:
            for _key_missing_required_value_errors in self.missing_required_value_errors:
                if self.missing_required_value_errors[_key_missing_required_value_errors] is not None:
                    _field_dict_of_array[_key_missing_required_value_errors] = [
                        _item.to_dict() for _item in self.missing_required_value_errors[_key_missing_required_value_errors]
                    ]
            _dict['missingRequiredValueErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_value_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_value_errors:
            for _key_invalid_value_errors in self.invalid_value_errors:
                if self.invalid_value_errors[_key_invalid_value_errors] is not None:
                    _field_dict_of_array[_key_invalid_value_errors] = [
                        _item.to_dict() for _item in self.invalid_value_errors[_key_invalid_value_errors]
                    ]
            _dict['invalidValueErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in already_existing_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.already_existing_uri_errors:
            for _key_already_existing_uri_errors in self.already_existing_uri_errors:
                if self.already_existing_uri_errors[_key_already_existing_uri_errors] is not None:
                    _field_dict_of_array[_key_already_existing_uri_errors] = [
                        _item.to_dict() for _item in self.already_existing_uri_errors[_key_already_existing_uri_errors]
                    ]
            _dict['alreadyExistingURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicate_uri_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicate_uri_errors:
            for _key_duplicate_uri_errors in self.duplicate_uri_errors:
                if self.duplicate_uri_errors[_key_duplicate_uri_errors] is not None:
                    _field_dict_of_array[_key_duplicate_uri_errors] = [
                        _item.to_dict() for _item in self.duplicate_uri_errors[_key_duplicate_uri_errors]
                    ]
            _dict['duplicateURIErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_row_size_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_row_size_errors:
            for _key_invalid_row_size_errors in self.invalid_row_size_errors:
                if self.invalid_row_size_errors[_key_invalid_row_size_errors] is not None:
                    _field_dict_of_array[_key_invalid_row_size_errors] = [
                        _item.to_dict() for _item in self.invalid_row_size_errors[_key_invalid_row_size_errors]
                    ]
            _dict['invalidRowSizeErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_date_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_date_errors:
            for _key_invalid_date_errors in self.invalid_date_errors:
                if self.invalid_date_errors[_key_invalid_date_errors] is not None:
                    _field_dict_of_array[_key_invalid_date_errors] = [
                        _item.to_dict() for _item in self.invalid_date_errors[_key_invalid_date_errors]
                    ]
            _dict['invalidDateErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of csv_header
        if self.csv_header:
            _dict['csvHeader'] = self.csv_header.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_object_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_object_errors:
            for _key_invalid_object_errors in self.invalid_object_errors:
                if self.invalid_object_errors[_key_invalid_object_errors] is not None:
                    _field_dict_of_array[_key_invalid_object_errors] = [
                        _item.to_dict() for _item in self.invalid_object_errors[_key_invalid_object_errors]
                    ]
            _dict['invalidObjectErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_annotation_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_annotation_errors:
            for _key_invalid_annotation_errors in self.invalid_annotation_errors:
                if self.invalid_annotation_errors[_key_invalid_annotation_errors] is not None:
                    _field_dict_of_array[_key_invalid_annotation_errors] = [
                        _item.to_dict() for _item in self.invalid_annotation_errors[_key_invalid_annotation_errors]
                    ]
            _dict['invalidAnnotationErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_target_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_target_errors:
            for _key_invalid_target_errors in self.invalid_target_errors:
                if self.invalid_target_errors[_key_invalid_target_errors] is not None:
                    _field_dict_of_array[_key_invalid_target_errors] = [
                        _item.to_dict() for _item in self.invalid_target_errors[_key_invalid_target_errors]
                    ]
            _dict['invalidTargetErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_data_type_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_data_type_errors:
            for _key_invalid_data_type_errors in self.invalid_data_type_errors:
                if self.invalid_data_type_errors[_key_invalid_data_type_errors] is not None:
                    _field_dict_of_array[_key_invalid_data_type_errors] = [
                        _item.to_dict() for _item in self.invalid_data_type_errors[_key_invalid_data_type_errors]
                    ]
            _dict['invalidDataTypeErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_experiment_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_experiment_errors:
            for _key_invalid_experiment_errors in self.invalid_experiment_errors:
                if self.invalid_experiment_errors[_key_invalid_experiment_errors] is not None:
                    _field_dict_of_array[_key_invalid_experiment_errors] = [
                        _item.to_dict() for _item in self.invalid_experiment_errors[_key_invalid_experiment_errors]
                    ]
            _dict['invalidExperimentErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in invalid_device_errors (dict of array)
        _field_dict_of_array = {}
        if self.invalid_device_errors:
            for _key_invalid_device_errors in self.invalid_device_errors:
                if self.invalid_device_errors[_key_invalid_device_errors] is not None:
                    _field_dict_of_array[_key_invalid_device_errors] = [
                        _item.to_dict() for _item in self.invalid_device_errors[_key_invalid_device_errors]
                    ]
            _dict['invalidDeviceErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in device_choice_ambiguity_errors (dict of array)
        _field_dict_of_array = {}
        if self.device_choice_ambiguity_errors:
            for _key_device_choice_ambiguity_errors in self.device_choice_ambiguity_errors:
                if self.device_choice_ambiguity_errors[_key_device_choice_ambiguity_errors] is not None:
                    _field_dict_of_array[_key_device_choice_ambiguity_errors] = [
                        _item.to_dict() for _item in self.device_choice_ambiguity_errors[_key_device_choice_ambiguity_errors]
                    ]
            _dict['deviceChoiceAmbiguityErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicated_data_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicated_data_errors:
            for _key_duplicated_data_errors in self.duplicated_data_errors:
                if self.duplicated_data_errors[_key_duplicated_data_errors] is not None:
                    _field_dict_of_array[_key_duplicated_data_errors] = [
                        _item.to_dict() for _item in self.duplicated_data_errors[_key_duplicated_data_errors]
                    ]
            _dict['duplicatedDataErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicated_object_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicated_object_errors:
            for _key_duplicated_object_errors in self.duplicated_object_errors:
                if self.duplicated_object_errors[_key_duplicated_object_errors] is not None:
                    _field_dict_of_array[_key_duplicated_object_errors] = [
                        _item.to_dict() for _item in self.duplicated_object_errors[_key_duplicated_object_errors]
                    ]
            _dict['duplicatedObjectErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicated_target_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicated_target_errors:
            for _key_duplicated_target_errors in self.duplicated_target_errors:
                if self.duplicated_target_errors[_key_duplicated_target_errors] is not None:
                    _field_dict_of_array[_key_duplicated_target_errors] = [
                        _item.to_dict() for _item in self.duplicated_target_errors[_key_duplicated_target_errors]
                    ]
            _dict['duplicatedTargetErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicated_experiment_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicated_experiment_errors:
            for _key_duplicated_experiment_errors in self.duplicated_experiment_errors:
                if self.duplicated_experiment_errors[_key_duplicated_experiment_errors] is not None:
                    _field_dict_of_array[_key_duplicated_experiment_errors] = [
                        _item.to_dict() for _item in self.duplicated_experiment_errors[_key_duplicated_experiment_errors]
                    ]
            _dict['duplicatedExperimentErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in duplicated_device_errors (dict of array)
        _field_dict_of_array = {}
        if self.duplicated_device_errors:
            for _key_duplicated_device_errors in self.duplicated_device_errors:
                if self.duplicated_device_errors[_key_duplicated_device_errors] is not None:
                    _field_dict_of_array[_key_duplicated_device_errors] = [
                        _item.to_dict() for _item in self.duplicated_device_errors[_key_duplicated_device_errors]
                    ]
            _dict['duplicatedDeviceErrors'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each item in annotations_on_objects (list)
        _items = []
        if self.annotations_on_objects:
            for _item_annotations_on_objects in self.annotations_on_objects:
                if _item_annotations_on_objects:
                    _items.append(_item_annotations_on_objects.to_dict())
            _dict['annotationsOnObjects'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DataCSVValidationModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "missingHeaders": obj.get("missingHeaders"),
            "emptyHeaders": obj.get("emptyHeaders"),
            "invalidHeaderURIs": obj.get("invalidHeaderURIs"),
            "datatypeErrors": dict(
                (_k,
                        [CSVDatatypeError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("datatypeErrors", {}).items()
            ),
            "uriNotFoundErrors": dict(
                (_k,
                        [CSVURINotFoundError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("uriNotFoundErrors", {}).items()
            ),
            "invalidURIErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidURIErrors", {}).items()
            ),
            "missingRequiredValueErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("missingRequiredValueErrors", {}).items()
            ),
            "invalidValueErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidValueErrors", {}).items()
            ),
            "alreadyExistingURIErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("alreadyExistingURIErrors", {}).items()
            ),
            "duplicateURIErrors": dict(
                (_k,
                        [CSVDuplicateURIError.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicateURIErrors", {}).items()
            ),
            "invalidRowSizeErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidRowSizeErrors", {}).items()
            ),
            "invalidDateErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidDateErrors", {}).items()
            ),
            "nbObjectImported": obj.get("nbObjectImported"),
            "validationToken": obj.get("validationToken"),
            "csvHeader": CsvHeader.from_dict(obj["csvHeader"]) if obj.get("csvHeader") is not None else None,
            "invalidObjectErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidObjectErrors", {}).items()
            ),
            "invalidAnnotationErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidAnnotationErrors", {}).items()
            ),
            "invalidTargetErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidTargetErrors", {}).items()
            ),
            "invalidDataTypeErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidDataTypeErrors", {}).items()
            ),
            "invalidExperimentErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidExperimentErrors", {}).items()
            ),
            "invalidDeviceErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("invalidDeviceErrors", {}).items()
            ),
            "deviceChoiceAmbiguityErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("deviceChoiceAmbiguityErrors", {}).items()
            ),
            "duplicatedDataErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicatedDataErrors", {}).items()
            ),
            "duplicatedObjectErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicatedObjectErrors", {}).items()
            ),
            "duplicatedTargetErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicatedTargetErrors", {}).items()
            ),
            "duplicatedExperimentErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicatedExperimentErrors", {}).items()
            ),
            "duplicatedDeviceErrors": dict(
                (_k,
                        [CSVCell.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("duplicatedDeviceErrors", {}).items()
            ),
            "headers": obj.get("headers"),
            "headersLabels": obj.get("headersLabels"),
            "annotationsOnObjects": [AnnotationModel.from_dict(_item) for _item in obj["annotationsOnObjects"]] if obj.get("annotationsOnObjects") is not None else None,
            "nbLinesImported": obj.get("nbLinesImported"),
            "nbLinesToImport": obj.get("nbLinesToImport"),
            "validationStep": obj.get("validationStep"),
            "insertionStep": obj.get("insertionStep"),
            "validCSV": obj.get("validCSV"),
            "tooLargeDataset": obj.get("tooLargeDataset"),
            "errorMessage": obj.get("errorMessage")
        })
        return _obj


