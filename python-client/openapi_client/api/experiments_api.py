# coding: utf-8

"""
    OpenSilex API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.4.7-rdg
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.data_csv_validation_dto import DataCSVValidationDTO
from openapi_client.models.data_get_dto import DataGetDTO
from openapi_client.models.experiment_creation_dto import ExperimentCreationDTO
from openapi_client.models.experiment_get_dto import ExperimentGetDTO
from openapi_client.models.experiment_get_list_dto import ExperimentGetListDTO
from openapi_client.models.facility_get_dto import FacilityGetDTO
from openapi_client.models.factor_details_get_dto import FactorDetailsGetDTO
from openapi_client.models.named_resource_dto import NamedResourceDTO
from openapi_client.models.provenance_get_dto import ProvenanceGetDTO
from openapi_client.models.species_dto import SpeciesDTO

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ExperimentsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_experiment(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Add an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_experiment_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Add an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_experiment_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_experiment_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/experiments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_experiment(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Delete an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_experiment_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Delete an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_experiment_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_experiment_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/core/experiments/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def export_experiment_data_list(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) export experiment data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenance: Search by provenance uri
        :type provenance: str
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data/export is deprecated.", DeprecationWarning)

        _param = self._export_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenance=provenance,
            metadata=metadata,
            operators=operators,
            mode=mode,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_experiment_data_list_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) export experiment data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenance: Search by provenance uri
        :type provenance: str
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data/export is deprecated.", DeprecationWarning)

        _param = self._export_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenance=provenance,
            metadata=metadata,
            operators=operators,
            mode=mode,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def export_experiment_data_list_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) export experiment data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenance: Search by provenance uri
        :type provenance: str
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data/export is deprecated.", DeprecationWarning)

        _param = self._export_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenance=provenance,
            metadata=metadata,
            operators=operators,
            mode=mode,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_experiment_data_list_serialize(
        self,
        uri,
        authorization,
        start_date,
        end_date,
        timezone,
        scientific_objects,
        variables,
        min_confidence,
        max_confidence,
        provenance,
        metadata,
        operators,
        mode,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scientific_objects': 'multi',
            'variables': 'multi',
            'operators': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if scientific_objects is not None:
            
            _query_params.append(('scientific_objects', scientific_objects))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if mode is not None:
            
            _query_params.append(('mode', mode))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/data/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_available_facilities(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FacilityGetDTO]:
        """Get facilities available for an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_facilities_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FacilityGetDTO]",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_available_facilities_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FacilityGetDTO]]:
        """Get facilities available for an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_facilities_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FacilityGetDTO]",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_available_facilities_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get facilities available for an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_facilities_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FacilityGetDTO]",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_available_facilities_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/available_facilities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_available_factors(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FactorDetailsGetDTO]:
        """Get factors with their levels associated to an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_factors_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FactorDetailsGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_available_factors_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FactorDetailsGetDTO]]:
        """Get factors with their levels associated to an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_factors_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FactorDetailsGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_available_factors_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get factors with their levels associated to an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_factors_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FactorDetailsGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_available_factors_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/factors',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_available_species(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpeciesDTO]:
        """Get species present in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_species_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpeciesDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_available_species_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpeciesDTO]]:
        """Get species present in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_species_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpeciesDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_available_species_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get species present in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_available_species_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpeciesDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_available_species_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/species',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_experiment(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExperimentGetDTO:
        """Get an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExperimentGetDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_experiment_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExperimentGetDTO]:
        """Get an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExperimentGetDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_experiment_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiment_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExperimentGetDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_experiment_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_experiments_by_uris(
        self,
        uris: Annotated[List[StrictStr], Field(description="Experiments URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExperimentGetListDTO]:
        """Get experiments URIs


        :param uris: Experiments URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiments_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_experiments_by_uris_with_http_info(
        self,
        uris: Annotated[List[StrictStr], Field(description="Experiments URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExperimentGetListDTO]]:
        """Get experiments URIs


        :param uris: Experiments URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiments_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_experiments_by_uris_without_preload_content(
        self,
        uris: Annotated[List[StrictStr], Field(description="Experiments URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get experiments URIs


        :param uris: Experiments URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiments_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_experiments_by_uris_serialize(
        self,
        uris,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'uris': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if uris is not None:
            
            _query_params.append(('uris', uris))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/by_uris',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_used_variables1(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[NamedResourceDTO]:
        """(Deprecated) Get variables involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scientific_objects: Search by objects uris
        :type scientific_objects: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/variables is deprecated.", DeprecationWarning)

        _param = self._get_used_variables1_serialize(
            uri=uri,
            authorization=authorization,
            scientific_objects=scientific_objects,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamedResourceDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_used_variables1_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[NamedResourceDTO]]:
        """(Deprecated) Get variables involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scientific_objects: Search by objects uris
        :type scientific_objects: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/variables is deprecated.", DeprecationWarning)

        _param = self._get_used_variables1_serialize(
            uri=uri,
            authorization=authorization,
            scientific_objects=scientific_objects,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamedResourceDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_used_variables1_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get variables involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scientific_objects: Search by objects uris
        :type scientific_objects: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/variables is deprecated.", DeprecationWarning)

        _param = self._get_used_variables1_serialize(
            uri=uri,
            authorization=authorization,
            scientific_objects=scientific_objects,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamedResourceDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_used_variables1_serialize(
        self,
        uri,
        authorization,
        scientific_objects,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scientific_objects': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if scientific_objects is not None:
            
            _query_params.append(('scientific_objects', scientific_objects))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/variables',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def import_csv_data1(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataCSVValidationDTO:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import is deprecated.", DeprecationWarning)

        _param = self._import_csv_data1_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def import_csv_data1_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataCSVValidationDTO]:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import is deprecated.", DeprecationWarning)

        _param = self._import_csv_data1_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def import_csv_data1_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import is deprecated.", DeprecationWarning)

        _param = self._import_csv_data1_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _import_csv_data1_serialize(
        self,
        uri,
        provenance,
        authorization,
        file,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/experiments/{uri}/data/import',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_experiment_data_list(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataGetDTO]:
        """(Deprecated) Search data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenance uri
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data is deprecated.", DeprecationWarning)

        _param = self._search_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_experiment_data_list_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataGetDTO]]:
        """(Deprecated) Search data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenance uri
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data is deprecated.", DeprecationWarning)

        _param = self._search_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_experiment_data_list_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        scientific_objects: Annotated[Optional[List[StrictStr]], Field(description="Search by objects")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uri")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Search data


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param scientific_objects: Search by objects
        :type scientific_objects: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenance uri
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/data is deprecated.", DeprecationWarning)

        _param = self._search_experiment_data_list_serialize(
            uri=uri,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            scientific_objects=scientific_objects,
            variables=variables,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_experiment_data_list_serialize(
        self,
        uri,
        authorization,
        start_date,
        end_date,
        timezone,
        scientific_objects,
        variables,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        operators,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scientific_objects': 'multi',
            'variables': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if scientific_objects is not None:
            
            _query_params.append(('scientific_objects', scientific_objects))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_experiment_provenances(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[StrictStr], Field(description="Search by agent URI")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """(Deprecated) Get provenances involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URI
        :type agent: str
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/provenances is deprecated.", DeprecationWarning)

        _param = self._search_experiment_provenances_serialize(
            uri=uri,
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_experiment_provenances_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[StrictStr], Field(description="Search by agent URI")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """(Deprecated) Get provenances involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URI
        :type agent: str
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/provenances is deprecated.", DeprecationWarning)

        _param = self._search_experiment_provenances_serialize(
            uri=uri,
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_experiment_provenances_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[StrictStr], Field(description="Search by agent URI")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get provenances involved in an experiment


        :param uri: Experiment URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URI
        :type agent: str
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/experiments/{uri}/provenances is deprecated.", DeprecationWarning)

        _param = self._search_experiment_provenances_serialize(
            uri=uri,
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_experiment_provenances_serialize(
        self,
        uri,
        authorization,
        name,
        description,
        activity,
        activity_type,
        agent,
        agent_type,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if activity is not None:
            
            _query_params.append(('activity', activity))
            
        if activity_type is not None:
            
            _query_params.append(('activity_type', activity_type))
            
        if agent is not None:
            
            _query_params.append(('agent', agent))
            
        if agent_type is not None:
            
            _query_params.append(('agent_type', agent_type))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments/{uri}/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_experiments(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Search by year")] = None,
        is_ended: Annotated[Optional[StrictBool], Field(description="Search ended(false) or active experiments(true)")] = None,
        species: Annotated[Optional[List[StrictStr]], Field(description="Search by involved species")] = None,
        factors: Annotated[Optional[List[StrictStr]], Field(description="Search by studied effect")] = None,
        projects: Annotated[Optional[List[StrictStr]], Field(description="Search by related project uri")] = None,
        is_public: Annotated[Optional[StrictBool], Field(description="Search private(false) or public experiments(true)")] = None,
        facilities: Annotated[Optional[List[StrictStr]], Field(description="Search by involved facilities")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExperimentGetListDTO]:
        """Search experiments


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param year: Search by year
        :type year: int
        :param is_ended: Search ended(false) or active experiments(true)
        :type is_ended: bool
        :param species: Search by involved species
        :type species: List[str]
        :param factors: Search by studied effect
        :type factors: List[str]
        :param projects: Search by related project uri
        :type projects: List[str]
        :param is_public: Search private(false) or public experiments(true)
        :type is_public: bool
        :param facilities: Search by involved facilities
        :type facilities: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_experiments_serialize(
            authorization=authorization,
            name=name,
            year=year,
            is_ended=is_ended,
            species=species,
            factors=factors,
            projects=projects,
            is_public=is_public,
            facilities=facilities,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_experiments_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Search by year")] = None,
        is_ended: Annotated[Optional[StrictBool], Field(description="Search ended(false) or active experiments(true)")] = None,
        species: Annotated[Optional[List[StrictStr]], Field(description="Search by involved species")] = None,
        factors: Annotated[Optional[List[StrictStr]], Field(description="Search by studied effect")] = None,
        projects: Annotated[Optional[List[StrictStr]], Field(description="Search by related project uri")] = None,
        is_public: Annotated[Optional[StrictBool], Field(description="Search private(false) or public experiments(true)")] = None,
        facilities: Annotated[Optional[List[StrictStr]], Field(description="Search by involved facilities")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExperimentGetListDTO]]:
        """Search experiments


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param year: Search by year
        :type year: int
        :param is_ended: Search ended(false) or active experiments(true)
        :type is_ended: bool
        :param species: Search by involved species
        :type species: List[str]
        :param factors: Search by studied effect
        :type factors: List[str]
        :param projects: Search by related project uri
        :type projects: List[str]
        :param is_public: Search private(false) or public experiments(true)
        :type is_public: bool
        :param facilities: Search by involved facilities
        :type facilities: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_experiments_serialize(
            authorization=authorization,
            name=name,
            year=year,
            is_ended=is_ended,
            species=species,
            factors=factors,
            projects=projects,
            is_public=is_public,
            facilities=facilities,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_experiments_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Search by year")] = None,
        is_ended: Annotated[Optional[StrictBool], Field(description="Search ended(false) or active experiments(true)")] = None,
        species: Annotated[Optional[List[StrictStr]], Field(description="Search by involved species")] = None,
        factors: Annotated[Optional[List[StrictStr]], Field(description="Search by studied effect")] = None,
        projects: Annotated[Optional[List[StrictStr]], Field(description="Search by related project uri")] = None,
        is_public: Annotated[Optional[StrictBool], Field(description="Search private(false) or public experiments(true)")] = None,
        facilities: Annotated[Optional[List[StrictStr]], Field(description="Search by involved facilities")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search experiments


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param year: Search by year
        :type year: int
        :param is_ended: Search ended(false) or active experiments(true)
        :type is_ended: bool
        :param species: Search by involved species
        :type species: List[str]
        :param factors: Search by studied effect
        :type factors: List[str]
        :param projects: Search by related project uri
        :type projects: List[str]
        :param is_public: Search private(false) or public experiments(true)
        :type is_public: bool
        :param facilities: Search by involved facilities
        :type facilities: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_experiments_serialize(
            authorization=authorization,
            name=name,
            year=year,
            is_ended=is_ended,
            species=species,
            factors=factors,
            projects=projects,
            is_public=is_public,
            facilities=facilities,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExperimentGetListDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_experiments_serialize(
        self,
        authorization,
        name,
        year,
        is_ended,
        species,
        factors,
        projects,
        is_public,
        facilities,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'species': 'multi',
            'factors': 'multi',
            'projects': 'multi',
            'facilities': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if is_ended is not None:
            
            _query_params.append(('is_ended', is_ended))
            
        if species is not None:
            
            _query_params.append(('species', species))
            
        if factors is not None:
            
            _query_params.append(('factors', factors))
            
        if projects is not None:
            
            _query_params.append(('projects', projects))
            
        if is_public is not None:
            
            _query_params.append(('is_public', is_public))
            
        if facilities is not None:
            
            _query_params.append(('facilities', facilities))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/experiments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_experiment(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_experiment_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_experiment_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ExperimentCreationDTO], Field(description="Experiment description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an experiment


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Experiment description
        :type body: ExperimentCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_experiment_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_experiment_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/core/experiments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_csv2(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataCSVValidationDTO:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import_validation is deprecated.", DeprecationWarning)

        _param = self._validate_csv2_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_csv2_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataCSVValidationDTO]:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import_validation is deprecated.", DeprecationWarning)

        _param = self._validate_csv2_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_csv2_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Experiment URI")],
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Import a CSV file for the given experiment URI and scientific object type.


        :param uri: Experiment URI (required)
        :type uri: str
        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/experiments/{uri}/data/import_validation is deprecated.", DeprecationWarning)

        _param = self._validate_csv2_serialize(
            uri=uri,
            provenance=provenance,
            authorization=authorization,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_csv2_serialize(
        self,
        uri,
        provenance,
        authorization,
        file,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/experiments/{uri}/data/import_validation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


