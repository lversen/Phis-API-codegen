# coding: utf-8

"""
    OpenSilex API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.4.7-rdg
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.data_csv_validation_dto import DataCSVValidationDTO
from openapi_client.models.data_confidence_dto import DataConfidenceDTO
from openapi_client.models.data_creation_dto import DataCreationDTO
from openapi_client.models.data_file_get_dto import DataFileGetDTO
from openapi_client.models.data_file_path_creation_dto import DataFilePathCreationDTO
from openapi_client.models.data_get_details_dto import DataGetDetailsDTO
from openapi_client.models.data_get_search_dto import DataGetSearchDTO
from openapi_client.models.data_search_dto import DataSearchDTO
from openapi_client.models.data_update_dto import DataUpdateDTO
from openapi_client.models.data_variable_series_get_dto import DataVariableSeriesGetDTO
from openapi_client.models.provenance_creation_dto import ProvenanceCreationDTO
from openapi_client.models.provenance_get_dto import ProvenanceGetDTO
from openapi_client.models.provenance_update_dto import ProvenanceUpdateDTO
from openapi_client.models.variable_get_dto import VariableGetDTO

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DataApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_list_data(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[DataCreationDTO]], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Add data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: List[DataCreationDTO]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_list_data_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_list_data_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[DataCreationDTO]], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Add data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: List[DataCreationDTO]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_list_data_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_list_data_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[DataCreationDTO]], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: List[DataCreationDTO]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_list_data_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_list_data_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def count_data(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Germplasm uris, can be an empty array but can't be null")] = None,
        count_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Count limit. Specify the maximum number of data to count. Set to 0 for no limit")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> int:
        """Count data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param germplasm_uris: Germplasm uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param count_limit: Count limit. Specify the maximum number of data to count. Set to 0 for no limit
        :type count_limit: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            group_of_germplasm=group_of_germplasm,
            germplasm_uris=germplasm_uris,
            count_limit=count_limit,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def count_data_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Germplasm uris, can be an empty array but can't be null")] = None,
        count_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Count limit. Specify the maximum number of data to count. Set to 0 for no limit")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[int]:
        """Count data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param germplasm_uris: Germplasm uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param count_limit: Count limit. Specify the maximum number of data to count. Set to 0 for no limit
        :type count_limit: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            group_of_germplasm=group_of_germplasm,
            germplasm_uris=germplasm_uris,
            count_limit=count_limit,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def count_data_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Germplasm uris, can be an empty array but can't be null")] = None,
        count_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Count limit. Specify the maximum number of data to count. Set to 0 for no limit")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Count data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param germplasm_uris: Germplasm uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param count_limit: Count limit. Specify the maximum number of data to count. Set to 0 for no limit
        :type count_limit: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            group_of_germplasm=group_of_germplasm,
            germplasm_uris=germplasm_uris,
            count_limit=count_limit,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _count_data_serialize(
        self,
        authorization,
        start_date,
        end_date,
        timezone,
        experiments,
        variables,
        devices,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        operators,
        group_of_germplasm,
        germplasm_uris,
        count_limit,
        accept_language,
        targets,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'germplasmUris': 'multi',
            'targets': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if group_of_germplasm is not None:
            
            _query_params.append(('group_of_germplasm', group_of_germplasm))
            
        if germplasm_uris is not None:
            
            _query_params.append(('germplasmUris', germplasm_uris))
            
        if count_limit is not None:
            
            _query_params.append(('count_limit', count_limit))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if targets is not None:
            _body_params = targets


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def count_datafiles(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        target: Annotated[Optional[List[StrictStr]], Field(description="Target URI")] = None,
        device: Annotated[Optional[List[StrictStr]], Field(description="Device URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> int:
        """Count datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param target: Target URI
        :type target: List[str]
        :param device: Device URI
        :type device: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_datafiles_serialize(
            authorization=authorization,
            target=target,
            device=device,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def count_datafiles_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        target: Annotated[Optional[List[StrictStr]], Field(description="Target URI")] = None,
        device: Annotated[Optional[List[StrictStr]], Field(description="Device URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[int]:
        """Count datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param target: Target URI
        :type target: List[str]
        :param device: Device URI
        :type device: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_datafiles_serialize(
            authorization=authorization,
            target=target,
            device=device,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def count_datafiles_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        target: Annotated[Optional[List[StrictStr]], Field(description="Target URI")] = None,
        device: Annotated[Optional[List[StrictStr]], Field(description="Device URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Count datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param target: Target URI
        :type target: List[str]
        :param device: Device URI
        :type device: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_datafiles_serialize(
            authorization=authorization,
            target=target,
            device=device,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _count_datafiles_serialize(
        self,
        authorization,
        target,
        device,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'target': 'multi',
            'device': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if target is not None:
            
            _query_params.append(('target', target))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_provenance(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceCreationDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Add a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_provenance_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceCreationDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Add a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_provenance_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceCreationDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceCreationDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_provenance_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_data(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Delete data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_data_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Delete data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_data_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_data_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/core/data/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_data_on_search(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiment: Annotated[Optional[StrictStr], Field(description="Search by experiment uri")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Search by target uri")] = None,
        variable: Annotated[Optional[StrictStr], Field(description="Search by variable uri")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Delete data on criteria


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiment: Search by experiment uri
        :type experiment: str
        :param target: Search by target uri
        :type target: str
        :param variable: Search by variable uri
        :type variable: str
        :param provenance: Search by provenance uri
        :type provenance: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_on_search_serialize(
            authorization=authorization,
            experiment=experiment,
            target=target,
            variable=variable,
            provenance=provenance,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_data_on_search_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiment: Annotated[Optional[StrictStr], Field(description="Search by experiment uri")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Search by target uri")] = None,
        variable: Annotated[Optional[StrictStr], Field(description="Search by variable uri")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Delete data on criteria


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiment: Search by experiment uri
        :type experiment: str
        :param target: Search by target uri
        :type target: str
        :param variable: Search by variable uri
        :type variable: str
        :param provenance: Search by provenance uri
        :type provenance: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_on_search_serialize(
            authorization=authorization,
            experiment=experiment,
            target=target,
            variable=variable,
            provenance=provenance,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_data_on_search_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiment: Annotated[Optional[StrictStr], Field(description="Search by experiment uri")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Search by target uri")] = None,
        variable: Annotated[Optional[StrictStr], Field(description="Search by variable uri")] = None,
        provenance: Annotated[Optional[StrictStr], Field(description="Search by provenance uri")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete data on criteria


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiment: Search by experiment uri
        :type experiment: str
        :param target: Search by target uri
        :type target: str
        :param variable: Search by variable uri
        :type variable: str
        :param provenance: Search by provenance uri
        :type provenance: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_data_on_search_serialize(
            authorization=authorization,
            experiment=experiment,
            target=target,
            variable=variable,
            provenance=provenance,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_data_on_search_serialize(
        self,
        authorization,
        experiment,
        target,
        variable,
        provenance,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiment is not None:
            
            _query_params.append(('experiment', experiment))
            
        if target is not None:
            
            _query_params.append(('target', target))
            
        if variable is not None:
            
            _query_params.append(('variable', variable))
            
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/core/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_provenance(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Delete a provenance that doesn't describe data


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_provenance_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Delete a provenance that doesn't describe data


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_provenance_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a provenance that doesn't describe data


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_provenance_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/core/provenances/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def export_data(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        with_raw_data: Annotated[Optional[StrictBool], Field(description="Export also raw_data")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets
        :type targets: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param with_raw_data: Export also raw_data
        :type with_raw_data: bool
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data/export is deprecated.", DeprecationWarning)

        _param = self._export_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            mode=mode,
            with_raw_data=with_raw_data,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_data_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        with_raw_data: Annotated[Optional[StrictBool], Field(description="Export also raw_data")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets
        :type targets: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param with_raw_data: Export also raw_data
        :type with_raw_data: bool
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data/export is deprecated.", DeprecationWarning)

        _param = self._export_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            mode=mode,
            with_raw_data=with_raw_data,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def export_data_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Format wide or long")] = None,
        with_raw_data: Annotated[Optional[StrictBool], Field(description="Export also raw_data")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets
        :type targets: List[str]
        :param variables: Search by variables
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param mode: Format wide or long
        :type mode: str
        :param with_raw_data: Export also raw_data
        :type with_raw_data: bool
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data/export is deprecated.", DeprecationWarning)

        _param = self._export_data_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            mode=mode,
            with_raw_data=with_raw_data,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_data_serialize(
        self,
        authorization,
        start_date,
        end_date,
        timezone,
        experiments,
        targets,
        variables,
        devices,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        operators,
        mode,
        with_raw_data,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if mode is not None:
            
            _query_params.append(('mode', mode))
            
        if with_raw_data is not None:
            
            _query_params.append(('with_raw_data', with_raw_data))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def export_data1(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataSearchDTO], Field(description="CSV export configuration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: CSV export configuration
        :type body: DataSearchDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_data1_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_data1_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataSearchDTO], Field(description="CSV export configuration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: CSV export configuration
        :type body: DataSearchDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_data1_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def export_data1_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataSearchDTO], Field(description="CSV export configuration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: CSV export configuration
        :type body: DataSearchDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_data1_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_data1_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataGetDetailsDTO:
        """Get data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataGetDetailsDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataGetDetailsDTO]:
        """Get data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataGetDetailsDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get data


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataGetDetailsDTO",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_file(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get a data file


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_file_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get a data file


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_file_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a data file


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_file_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_file_description(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataFileGetDTO:
        """Get a data file description


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_description_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataFileGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_file_description_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataFileGetDTO]:
        """Get a data file description


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_description_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataFileGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_file_description_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a data file description


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_description_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataFileGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_file_description_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles/{uri}/description',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_file_descriptions_by_search(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris list")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataFileGetDTO]:
        """Search data files


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param targets: Search by targets uris list
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_search_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_file_descriptions_by_search_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris list")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataFileGetDTO]]:
        """Search data files


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param targets: Search by targets uris list
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_search_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_file_descriptions_by_search_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris list")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search data files


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param targets: Search by targets uris list
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_search_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_file_descriptions_by_search_serialize(
        self,
        authorization,
        rdf_type,
        start_date,
        end_date,
        timezone,
        experiments,
        targets,
        devices,
        provenances,
        metadata,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if rdf_type is not None:
            
            _query_params.append(('rdf_type', rdf_type))
            
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_file_descriptions_by_targets(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataFileGetDTO]:
        """Search data files for a large list of targets 


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_targets_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_file_descriptions_by_targets_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataFileGetDTO]]:
        """Search data files for a large list of targets 


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_targets_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_file_descriptions_by_targets_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        rdf_type: Annotated[Optional[StrictStr], Field(description="Search by rdf type uri")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiments")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris list")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search data files for a large list of targets 


        :param authorization: Authentication token (required)
        :type authorization: str
        :param rdf_type: Search by rdf type uri
        :type rdf_type: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiments
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param provenances: Search by provenance uris list
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_file_descriptions_by_targets_serialize(
            authorization=authorization,
            rdf_type=rdf_type,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            devices=devices,
            provenances=provenances,
            metadata=metadata,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataFileGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_file_descriptions_by_targets_serialize(
        self,
        authorization,
        rdf_type,
        start_date,
        end_date,
        timezone,
        experiments,
        devices,
        provenances,
        metadata,
        order_by,
        page,
        page_size,
        accept_language,
        targets,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'order_by': 'multi',
            'targets': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if rdf_type is not None:
            
            _query_params.append(('rdf_type', rdf_type))
            
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if targets is not None:
            _body_params = targets


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/datafiles/by_targets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_list_by_targets(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataGetSearchDTO]:
        """(Deprecated) Search data for a large list of targets

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/data/by_targets is deprecated.", DeprecationWarning)

        _param = self._get_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_list_by_targets_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataGetSearchDTO]]:
        """(Deprecated) Search data for a large list of targets

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/data/by_targets is deprecated.", DeprecationWarning)

        _param = self._get_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_list_by_targets_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Search data for a large list of targets

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /core/data/by_targets is deprecated.", DeprecationWarning)

        _param = self._get_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_list_by_targets_serialize(
        self,
        authorization,
        start_date,
        end_date,
        timezone,
        experiments,
        variables,
        devices,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        group_of_germplasm,
        operators,
        germplasm_uris,
        order_by,
        page,
        page_size,
        accept_language,
        targets,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'germplasmUris': 'multi',
            'order_by': 'multi',
            'targets': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if group_of_germplasm is not None:
            
            _query_params.append(('group_of_germplasm', group_of_germplasm))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if germplasm_uris is not None:
            
            _query_params.append(('germplasmUris', germplasm_uris))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if targets is not None:
            _body_params = targets


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/by_targets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_data_series_by_facility(
        self,
        variable: Annotated[StrictStr, Field(description="variable URI")],
        target: Annotated[StrictStr, Field(description="target URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        calculated_only: Annotated[Optional[StrictBool], Field(description="Retreive calculated series only")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataVariableSeriesGetDTO:
        """Get all data series associated with a facility


        :param variable: variable URI (required)
        :type variable: str
        :param target: target URI (required)
        :type target: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param calculated_only: Retreive calculated series only
        :type calculated_only: bool
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_series_by_facility_serialize(
            variable=variable,
            target=target,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            calculated_only=calculated_only,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataVariableSeriesGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_data_series_by_facility_with_http_info(
        self,
        variable: Annotated[StrictStr, Field(description="variable URI")],
        target: Annotated[StrictStr, Field(description="target URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        calculated_only: Annotated[Optional[StrictBool], Field(description="Retreive calculated series only")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataVariableSeriesGetDTO]:
        """Get all data series associated with a facility


        :param variable: variable URI (required)
        :type variable: str
        :param target: target URI (required)
        :type target: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param calculated_only: Retreive calculated series only
        :type calculated_only: bool
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_series_by_facility_serialize(
            variable=variable,
            target=target,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            calculated_only=calculated_only,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataVariableSeriesGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_data_series_by_facility_without_preload_content(
        self,
        variable: Annotated[StrictStr, Field(description="variable URI")],
        target: Annotated[StrictStr, Field(description="target URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        calculated_only: Annotated[Optional[StrictBool], Field(description="Retreive calculated series only")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all data series associated with a facility


        :param variable: variable URI (required)
        :type variable: str
        :param target: target URI (required)
        :type target: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param calculated_only: Retreive calculated series only
        :type calculated_only: bool
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_data_series_by_facility_serialize(
            variable=variable,
            target=target,
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            calculated_only=calculated_only,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataVariableSeriesGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_data_series_by_facility_serialize(
        self,
        variable,
        target,
        authorization,
        start_date,
        end_date,
        calculated_only,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if variable is not None:
            
            _query_params.append(('variable', variable))
            
        if target is not None:
            
            _query_params.append(('target', target))
            
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if calculated_only is not None:
            
            _query_params.append(('calculated_only', calculated_only))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/data_serie/facility',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_datafiles_provenances(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Search provenances linked to datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_datafiles_provenances_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Search provenances linked to datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_datafiles_provenances_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search provenances linked to datafiles


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_datafiles_provenances_serialize(
        self,
        authorization,
        experiments,
        targets,
        devices,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'devices': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_datafiles_provenances_by_targets(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Search provenances linked to datafiles for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Search by targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_datafiles_provenances_by_targets_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Search provenances linked to datafiles for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Search by targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_datafiles_provenances_by_targets_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search provenances linked to datafiles for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Search by targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_datafiles_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_datafiles_provenances_by_targets_serialize(
        self,
        authorization,
        experiments,
        devices,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'devices': 'multi',
            'body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/datafiles/provenances/by_targets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_mathematical_operators(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Get mathematical operators


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mathematical_operators_serialize(
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_mathematical_operators_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Get mathematical operators


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mathematical_operators_serialize(
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_mathematical_operators_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get mathematical operators


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mathematical_operators_serialize(
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_mathematical_operators_serialize(
        self,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/mathematicalOperators',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pictures_thumbnails(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scaled_width: Annotated[Optional[Annotated[int, Field(le=1920, strict=True, ge=256)]], Field(description="Thumbnail width")] = None,
        scaled_height: Annotated[Optional[Annotated[int, Field(le=1080, strict=True, ge=144)]], Field(description="Thumbnail height")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get a picture thumbnail


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scaled_width: Thumbnail width
        :type scaled_width: int
        :param scaled_height: Thumbnail height
        :type scaled_height: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pictures_thumbnails_serialize(
            uri=uri,
            authorization=authorization,
            scaled_width=scaled_width,
            scaled_height=scaled_height,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pictures_thumbnails_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scaled_width: Annotated[Optional[Annotated[int, Field(le=1920, strict=True, ge=256)]], Field(description="Thumbnail width")] = None,
        scaled_height: Annotated[Optional[Annotated[int, Field(le=1080, strict=True, ge=144)]], Field(description="Thumbnail height")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get a picture thumbnail


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scaled_width: Thumbnail width
        :type scaled_width: int
        :param scaled_height: Thumbnail height
        :type scaled_height: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pictures_thumbnails_serialize(
            uri=uri,
            authorization=authorization,
            scaled_width=scaled_width,
            scaled_height=scaled_height,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pictures_thumbnails_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Search by fileUri")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        scaled_width: Annotated[Optional[Annotated[int, Field(le=1920, strict=True, ge=256)]], Field(description="Thumbnail width")] = None,
        scaled_height: Annotated[Optional[Annotated[int, Field(le=1080, strict=True, ge=144)]], Field(description="Thumbnail height")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a picture thumbnail


        :param uri: Search by fileUri (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param scaled_width: Thumbnail width
        :type scaled_width: int
        :param scaled_height: Thumbnail height
        :type scaled_height: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pictures_thumbnails_serialize(
            uri=uri,
            authorization=authorization,
            scaled_width=scaled_width,
            scaled_height=scaled_height,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pictures_thumbnails_serialize(
        self,
        uri,
        authorization,
        scaled_width,
        scaled_height,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        if scaled_width is not None:
            
            _query_params.append(('scaled_width', scaled_width))
            
        if scaled_height is not None:
            
            _query_params.append(('scaled_height', scaled_height))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/datafiles/{uri}/thumbnail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_provenance(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProvenanceGetDTO:
        """Get a provenance


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProvenanceGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_provenance_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProvenanceGetDTO]:
        """Get a provenance


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProvenanceGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_provenance_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a provenance


        :param uri: Provenance URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenance_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProvenanceGetDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_provenance_serialize(
        self,
        uri,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/provenances/{uri}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_provenances_by_uris(
        self,
        uris: Annotated[List[StrictStr], Field(description="Provenances URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Get a list of provenances by their URIs


        :param uris: Provenances URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenances_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_provenances_by_uris_with_http_info(
        self,
        uris: Annotated[List[StrictStr], Field(description="Provenances URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Get a list of provenances by their URIs


        :param uris: Provenances URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenances_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_provenances_by_uris_without_preload_content(
        self,
        uris: Annotated[List[StrictStr], Field(description="Provenances URIs")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of provenances by their URIs


        :param uris: Provenances URIs (required)
        :type uris: List[str]
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_provenances_by_uris_serialize(
            uris=uris,
            authorization=authorization,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
            '400': "ErrorDTO",
            '404': "ErrorDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_provenances_by_uris_serialize(
        self,
        uris,
        authorization,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'uris': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if uris is not None:
            
            _query_params.append(('uris', uris))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/provenances/by_uris',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_used_provenances(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Search provenances linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_used_provenances_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Search provenances linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_used_provenances_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search provenances linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_used_provenances_serialize(
        self,
        authorization,
        experiments,
        targets,
        variables,
        devices,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'variables': 'multi',
            'devices': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_used_provenances_by_targets(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Search provenances linked to data for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_used_provenances_by_targets_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Search provenances linked to data for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_used_provenances_by_targets_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[List[StrictStr]], Field(description="Targets uris")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search provenances linked to data for a large list of targets


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Targets uris
        :type body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_provenances_by_targets_serialize(
            authorization=authorization,
            experiments=experiments,
            variables=variables,
            devices=devices,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_used_provenances_by_targets_serialize(
        self,
        authorization,
        experiments,
        variables,
        devices,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/provenances/by_targets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_used_variables(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by device uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VariableGetDTO]:
        """Get variables linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param provenances: Search by provenance uris
        :type provenances: List[str]
        :param devices: Search by device uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_variables_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            provenances=provenances,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VariableGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_used_variables_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by device uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VariableGetDTO]]:
        """Get variables linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param provenances: Search by provenance uris
        :type provenances: List[str]
        :param devices: Search by device uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_variables_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            provenances=provenances,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VariableGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_used_variables_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenance uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by device uris")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get variables linked to data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param provenances: Search by provenance uris
        :type provenances: List[str]
        :param devices: Search by device uris
        :type devices: List[str]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_used_variables_serialize(
            authorization=authorization,
            experiments=experiments,
            targets=targets,
            provenances=provenances,
            devices=devices,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VariableGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_used_variables_serialize(
        self,
        authorization,
        experiments,
        targets,
        provenances,
        devices,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'provenances': 'multi',
            'devices': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data/variables',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def import_csv_data(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataCSVValidationDTO:
        """Import a CSV file for the given provenanceURI


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._import_csv_data_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def import_csv_data_with_http_info(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataCSVValidationDTO]:
        """Import a CSV file for the given provenanceURI


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._import_csv_data_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def import_csv_data_without_preload_content(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import a CSV file for the given provenanceURI


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._import_csv_data_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _import_csv_data_serialize(
        self,
        provenance,
        authorization,
        file,
        experiment,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        if experiment is not None:
            
            _query_params.append(('experiment', experiment))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/import',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_data_file(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        description: Annotated[StrictStr, Field(description="File description with metadata")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Add a data file

        {\"rdf_type\":\"http://www.opensilex.org/vocabulary/oeso#Image\", \"date\":\"2020-08-21T00:00:00+01:00\", \"target\":\"http://plot01\", \"provenance\": { \"uri\":\"http://opensilex.dev/provenance/1598001689415\" }, \"metadata\":{ \"LabelView\" : \"side90\", \"paramA\" : \"90\"}}

        :param authorization: Authentication token (required)
        :type authorization: str
        :param description: File description with metadata (required)
        :type description: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_serialize(
            authorization=authorization,
            description=description,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_data_file_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        description: Annotated[StrictStr, Field(description="File description with metadata")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Add a data file

        {\"rdf_type\":\"http://www.opensilex.org/vocabulary/oeso#Image\", \"date\":\"2020-08-21T00:00:00+01:00\", \"target\":\"http://plot01\", \"provenance\": { \"uri\":\"http://opensilex.dev/provenance/1598001689415\" }, \"metadata\":{ \"LabelView\" : \"side90\", \"paramA\" : \"90\"}}

        :param authorization: Authentication token (required)
        :type authorization: str
        :param description: File description with metadata (required)
        :type description: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_serialize(
            authorization=authorization,
            description=description,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_data_file_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        description: Annotated[StrictStr, Field(description="File description with metadata")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Data file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add a data file

        {\"rdf_type\":\"http://www.opensilex.org/vocabulary/oeso#Image\", \"date\":\"2020-08-21T00:00:00+01:00\", \"target\":\"http://plot01\", \"provenance\": { \"uri\":\"http://opensilex.dev/provenance/1598001689415\" }, \"metadata\":{ \"LabelView\" : \"side90\", \"paramA\" : \"90\"}}

        :param authorization: Authentication token (required)
        :type authorization: str
        :param description: File description with metadata (required)
        :type description: str
        :param file: Data file (required)
        :type file: bytearray
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_serialize(
            authorization=authorization,
            description=description,
            file=file,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_data_file_serialize(
        self,
        authorization,
        description,
        file,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        if description is not None:
            _form_params.append(('description', description))
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/datafiles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_data_file_paths(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        body: Annotated[List[DataFilePathCreationDTO], Field(description="Metadata of the file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Describe datafiles and give their relative paths in the configured storage system. In the case of already stored datafiles.


        :param authorization: Authentication token (required)
        :type authorization: str
        :param body: Metadata of the file (required)
        :type body: List[DataFilePathCreationDTO]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_paths_serialize(
            authorization=authorization,
            body=body,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_data_file_paths_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        body: Annotated[List[DataFilePathCreationDTO], Field(description="Metadata of the file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Describe datafiles and give their relative paths in the configured storage system. In the case of already stored datafiles.


        :param authorization: Authentication token (required)
        :type authorization: str
        :param body: Metadata of the file (required)
        :type body: List[DataFilePathCreationDTO]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_paths_serialize(
            authorization=authorization,
            body=body,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_data_file_paths_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        body: Annotated[List[DataFilePathCreationDTO], Field(description="Metadata of the file")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Describe datafiles and give their relative paths in the configured storage system. In the case of already stored datafiles.


        :param authorization: Authentication token (required)
        :type authorization: str
        :param body: Metadata of the file (required)
        :type body: List[DataFilePathCreationDTO]
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_data_file_paths_serialize(
            authorization=authorization,
            body=body,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_data_file_paths_serialize(
        self,
        authorization,
        body,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/datafiles/description',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_data_list(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataGetSearchDTO]:
        """(Deprecated) Search data

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data is deprecated.", DeprecationWarning)

        _param = self._search_data_list_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_data_list_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataGetSearchDTO]]:
        """(Deprecated) Search data

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data is deprecated.", DeprecationWarning)

        _param = self._search_data_list_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_data_list_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Search by targets uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Search data

        Deprecated. Use searchDataListByTargets (/search) service which is more optimized

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param targets: Search by targets uris
        :type targets: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param operators: Search by operators
        :type operators: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /core/data is deprecated.", DeprecationWarning)

        _param = self._search_data_list_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            targets=targets,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            operators=operators,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_data_list_serialize(
        self,
        authorization,
        start_date,
        end_date,
        timezone,
        experiments,
        targets,
        variables,
        devices,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        operators,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'targets': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if targets is not None:
            
            _query_params.append(('targets', targets))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_data_list_by_targets(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DataGetSearchDTO]:
        """Search data for a large list of targets

        Optimized search. The total count of element is not returned. Use countData (/count) service in order to get exact count of element

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_data_list_by_targets_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DataGetSearchDTO]]:
        """Search data for a large list of targets

        Optimized search. The total count of element is not returned. Use countData (/count) service in order to get exact count of element

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_data_list_by_targets_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        start_date: Annotated[Optional[StrictStr], Field(description="Search by minimal date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="Search by maximal date")] = None,
        timezone: Annotated[Optional[StrictStr], Field(description="Precise the timezone corresponding to the given dates")] = None,
        experiments: Annotated[Optional[List[StrictStr]], Field(description="Search by experiment uris")] = None,
        variables: Annotated[Optional[List[StrictStr]], Field(description="Search by variables uris")] = None,
        devices: Annotated[Optional[List[StrictStr]], Field(description="Search by devices uris")] = None,
        min_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by minimal confidence index")] = None,
        max_confidence: Annotated[Optional[Union[Annotated[float, Field(le=1, strict=True, ge=0)], Annotated[int, Field(le=1, strict=True, ge=0)]]], Field(description="Search by maximal confidence index")] = None,
        provenances: Annotated[Optional[List[StrictStr]], Field(description="Search by provenances")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="Search by metadata")] = None,
        group_of_germplasm: Annotated[Optional[StrictStr], Field(description="Group filter")] = None,
        operators: Annotated[Optional[List[StrictStr]], Field(description="Search by operators")] = None,
        germplasm_uris: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        targets: Annotated[Optional[List[StrictStr]], Field(description="Targets uris, can be an empty array but can't be null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search data for a large list of targets

        Optimized search. The total count of element is not returned. Use countData (/count) service in order to get exact count of element

        :param authorization: Authentication token (required)
        :type authorization: str
        :param start_date: Search by minimal date
        :type start_date: str
        :param end_date: Search by maximal date
        :type end_date: str
        :param timezone: Precise the timezone corresponding to the given dates
        :type timezone: str
        :param experiments: Search by experiment uris
        :type experiments: List[str]
        :param variables: Search by variables uris
        :type variables: List[str]
        :param devices: Search by devices uris
        :type devices: List[str]
        :param min_confidence: Search by minimal confidence index
        :type min_confidence: float
        :param max_confidence: Search by maximal confidence index
        :type max_confidence: float
        :param provenances: Search by provenances
        :type provenances: List[str]
        :param metadata: Search by metadata
        :type metadata: str
        :param group_of_germplasm: Group filter
        :type group_of_germplasm: str
        :param operators: Search by operators
        :type operators: List[str]
        :param germplasm_uris: Targets uris, can be an empty array but can't be null
        :type germplasm_uris: List[str]
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param targets: Targets uris, can be an empty array but can't be null
        :type targets: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_data_list_by_targets_serialize(
            authorization=authorization,
            start_date=start_date,
            end_date=end_date,
            timezone=timezone,
            experiments=experiments,
            variables=variables,
            devices=devices,
            min_confidence=min_confidence,
            max_confidence=max_confidence,
            provenances=provenances,
            metadata=metadata,
            group_of_germplasm=group_of_germplasm,
            operators=operators,
            germplasm_uris=germplasm_uris,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            targets=targets,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DataGetSearchDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_data_list_by_targets_serialize(
        self,
        authorization,
        start_date,
        end_date,
        timezone,
        experiments,
        variables,
        devices,
        min_confidence,
        max_confidence,
        provenances,
        metadata,
        group_of_germplasm,
        operators,
        germplasm_uris,
        order_by,
        page,
        page_size,
        accept_language,
        targets,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'experiments': 'multi',
            'variables': 'multi',
            'devices': 'multi',
            'provenances': 'multi',
            'operators': 'multi',
            'germplasmUris': 'multi',
            'order_by': 'multi',
            'targets': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            
            _query_params.append(('end_date', end_date))
            
        if timezone is not None:
            
            _query_params.append(('timezone', timezone))
            
        if experiments is not None:
            
            _query_params.append(('experiments', experiments))
            
        if variables is not None:
            
            _query_params.append(('variables', variables))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if max_confidence is not None:
            
            _query_params.append(('max_confidence', max_confidence))
            
        if provenances is not None:
            
            _query_params.append(('provenances', provenances))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if group_of_germplasm is not None:
            
            _query_params.append(('group_of_germplasm', group_of_germplasm))
            
        if operators is not None:
            
            _query_params.append(('operators', operators))
            
        if germplasm_uris is not None:
            
            _query_params.append(('germplasmUris', germplasm_uris))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if targets is not None:
            _body_params = targets


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_provenance(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[List[StrictStr]], Field(description="Search by agent URIs")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProvenanceGetDTO]:
        """Get provenances


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URIs
        :type agent: List[str]
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_provenance_serialize(
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_provenance_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[List[StrictStr]], Field(description="Search by agent URIs")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProvenanceGetDTO]]:
        """Get provenances


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URIs
        :type agent: List[str]
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_provenance_serialize(
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_provenance_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        name: Annotated[Optional[StrictStr], Field(description="Regex pattern for filtering by name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Search by description")] = None,
        activity: Annotated[Optional[StrictStr], Field(description="Search by activity URI")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="Search by activity type")] = None,
        agent: Annotated[Optional[List[StrictStr]], Field(description="Search by agent URIs")] = None,
        agent_type: Annotated[Optional[StrictStr], Field(description="Search by agent type")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="List of fields to sort as an array of fieldName=asc|desc")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get provenances


        :param authorization: Authentication token (required)
        :type authorization: str
        :param name: Regex pattern for filtering by name
        :type name: str
        :param description: Search by description
        :type description: str
        :param activity: Search by activity URI
        :type activity: str
        :param activity_type: Search by activity type
        :type activity_type: str
        :param agent: Search by agent URIs
        :type agent: List[str]
        :param agent_type: Search by agent type
        :type agent_type: str
        :param order_by: List of fields to sort as an array of fieldName=asc|desc
        :type order_by: List[str]
        :param page: Page number
        :type page: int
        :param page_size: Page size
        :type page_size: int
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_provenance_serialize(
            authorization=authorization,
            name=name,
            description=description,
            activity=activity,
            activity_type=activity_type,
            agent=agent,
            agent_type=agent_type,
            order_by=order_by,
            page=page,
            page_size=page_size,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProvenanceGetDTO]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_provenance_serialize(
        self,
        authorization,
        name,
        description,
        activity,
        activity_type,
        agent,
        agent_type,
        order_by,
        page,
        page_size,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'agent': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if activity is not None:
            
            _query_params.append(('activity', activity))
            
        if activity_type is not None:
            
            _query_params.append(('activity_type', activity_type))
            
        if agent is not None:
            
            _query_params.append(('agent', agent))
            
        if agent_type is not None:
            
            _query_params.append(('agent_type', agent_type))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/core/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataUpdateDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataUpdateDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataUpdateDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update data


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/core/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_confidence(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataConfidenceDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update confidence index


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataConfidenceDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_confidence_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_confidence_with_http_info(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataConfidenceDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update confidence index


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataConfidenceDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_confidence_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_confidence_without_preload_content(
        self,
        uri: Annotated[StrictStr, Field(description="Data URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[DataConfidenceDTO], Field(description="Data description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update confidence index


        :param uri: Data URI (required)
        :type uri: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Data description
        :type body: DataConfidenceDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_confidence_serialize(
            uri=uri,
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
            '400': "ErrorResponse",
            '500': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_confidence_serialize(
        self,
        uri,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if uri is not None:
            _path_params['uri'] = uri
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/core/data/{uri}/confidence',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_provenance(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceUpdateDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_provenance_with_http_info(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceUpdateDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_provenance_without_preload_content(
        self,
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        body: Annotated[Optional[ProvenanceUpdateDTO], Field(description="Provenance description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a provenance


        :param authorization: Authentication token (required)
        :type authorization: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param body: Provenance description
        :type body: ProvenanceUpdateDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_provenance_serialize(
            authorization=authorization,
            accept_language=accept_language,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_provenance_serialize(
        self,
        authorization,
        accept_language,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/core/provenances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_csv(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataCSVValidationDTO:
        """Import a CSV file for the given provenanceURI.


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_csv_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_csv_with_http_info(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataCSVValidationDTO]:
        """Import a CSV file for the given provenanceURI.


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_csv_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_csv_without_preload_content(
        self,
        provenance: Annotated[StrictStr, Field(description="Provenance URI")],
        authorization: Annotated[StrictStr, Field(description="Authentication token")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="File")],
        experiment: Annotated[Optional[StrictStr], Field(description="Experiment URI")] = None,
        accept_language: Annotated[Optional[StrictStr], Field(description="Request accepted language")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import a CSV file for the given provenanceURI.


        :param provenance: Provenance URI (required)
        :type provenance: str
        :param authorization: Authentication token (required)
        :type authorization: str
        :param file: File (required)
        :type file: bytearray
        :param experiment: Experiment URI
        :type experiment: str
        :param accept_language: Request accepted language
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_csv_serialize(
            provenance=provenance,
            authorization=authorization,
            file=file,
            experiment=experiment,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DataCSVValidationDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_csv_serialize(
        self,
        provenance,
        authorization,
        file,
        experiment,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provenance is not None:
            
            _query_params.append(('provenance', provenance))
            
        if experiment is not None:
            
            _query_params.append(('experiment', experiment))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/core/data/import_validation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


